<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#@ template hostSpecific="true"#>
<# var datatype = new string [] {"Guid" , "Guid"}; #>
<# var properties = new string [] {"QuestionItemUniqueId", "QuestionItemUniqueIdV3"}; #>
<# var project = "LegacySync"; #>
<# var repository = "QuestionItemMapping"; #>
<# var aggregate = "QuestionItemMapping" ; #>
<# var classname = "QuestionItemMapping"; #>
<# var appCommands = true ; #>
<# var numberOfSteps = 0; #>
<# var version = true; #>
using HC.Common;
using HC.Common.Presentation.Security;
using HC.<#= project #>.Api.Areas.API.Controllers;
using HC.<#= project #>.Application;
using HC.<#= project #>.Application.Models.InputModel.<#= aggregate #>;
using HC.<#= project #>.Application.Models.ViewModel.<#= aggregate #>;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;

namespace HC.<#= project #>.Api.Areas.API.Controllers
{
    [AuthorizeTenant(NeedsAdminAccess = true)]
    [Route("V4.0/{cultureInfo:length(2):alpha}/tenant/{tenantUniqueId:guid}/<#= aggregate #>")]
    public class <#= aggregate #>Controller : BaseController
    {
        private readonly <#= aggregate #>AS <#= aggregate.ToLower() #>AS;
        private readonly AppSettings appSettings;

        public <#= aggregate #>Controller()
        {
            <#= aggregate.ToLower() #>AS = ObjectContainer.Resolve<<#= aggregate #>AS>();
            appSettings = ObjectContainer.Resolve<AppSettings>();

            Condition.Requires(<#= aggregate.ToLower() #>AS, nameof(<#= aggregate.ToLower() #>AS)).IsNotNull();
            Condition.Requires(appSettings, nameof(appSettings)).IsNotNull();
        }

        [ProducesResponseType(statusCode: 200)]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpPost("Create")]
        public async Task<IActionResult> Create(
            [FromRoute]string cultureInfo,
            [FromBody]CreateA<#= aggregate #>IM model)
        {
            // Handle possible exceptions
            return await Exception.HandleForLoggingAsync(model.CorrelationUniqueId, model, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(Membership.GetToken().User.Id), UniqueId.CreateIfNotNull(model.CorrelationUniqueId), model);

                // Handle request
                var result = await <#= aggregate.ToLower() #>AS.CreateAsync(Membership.GetToken().User.Id, model);

                // Log response
                Log.Response(Request, sw, UniqueId.CreateIfNotNull(model.CorrelationUniqueId), result);

                // Return response
                if (result.IsValid)
                    return Ok();
                else
                    return BadRequest(result.Errors);
            });
        }

        [ProducesResponseType(statusCode: 200)]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpPut("Update")]
        public async Task<IActionResult> Update(
            [FromRoute]string cultureInfo,
            [FromBody]Update<#= aggregate #>IM model)
        {
            // Handle possible exceptions
            return await Exception.HandleForLoggingAsync(model.CorrelationUniqueId, model, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(Membership.GetToken().User.Id), UniqueId.CreateIfNotNull(model.CorrelationUniqueId), model);

                // Handle request
                var result = await <#= aggregate.ToLower() #>AS.UpdateAsync(Membership.GetToken().User.Id, model);

                // Log response
                Log.Response(Request, sw, UniqueId.CreateIfNotNull(model.CorrelationUniqueId), result);

                // Return response
                if (result.IsValid)
                    return Ok();
                else
                    return BadRequest(result.Errors);
            });
        }


        [ProducesResponseType(statusCode: 200)]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpPut("Delete")]
        public async Task<IActionResult> Delete(
            [FromRoute]string cultureInfo,
            [FromBody]DeleteA<#= aggregate #>IM model)
        {
            // Handle possible exceptions
            return await Exception.HandleForLoggingAsync(model.CorrelationUniqueId, model, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(Membership.GetToken().User.Id), UniqueId.CreateIfNotNull(model.CorrelationUniqueId), model);

                // Handle request
                var result = await <#= aggregate.ToLower() #>AS.DeleteAsync(Membership.GetToken().User.Id, model);

                // Log response
                Log.Response(Request, sw, UniqueId.CreateIfNotNull(model.CorrelationUniqueId), result);

                // Return response
                if (result.IsValid)
				    return Ok();
                else
                    return BadRequest(result.Errors);
 
            });
        }


        [ProducesResponseType(statusCode: 200, type: typeof(<#= aggregate #>VM[]))]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpGet("GetAll")]
        public async Task<IActionResult> GetAll(
            [FromRoute] string cultureInfo,
            [FromRoute] Guid tenantUniqueId
            )
        {
            // Generate query id
            var queryUniqueId = UniqueId.Generate();

            // Handle possible exceptions
            return await Exception.HandleForLoggingAsync(queryUniqueId.Value, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(Membership.GetToken().User.Id), queryUniqueId);

                // Handle request
                var result = await <#= aggregate.ToLower() #>AS.GetAllAsync(appSettings.Security.SuperTenantUniqueId, queryUniqueId.Value, Membership.GetToken().User.Id);

                // Log response
                Log.Response(Request, sw, queryUniqueId, result);

                // Return response
                if (result.IsValid)
                    return Ok(result.Object);
                else
                    return BadRequest(result.Errors);
            });
        }
    }
}              
<#
  // End of file.
  SaveOutput(aggregate + "Controller.cs");
  #>
using System.Collections.Generic;
using HC.Common;
using System.Diagnostics;
using System.Threading.Tasks;
using HC.Common.Infrastructure.DomainPersistence;
using HC.<#= project #>.Application.Models.ViewModel.<#= aggregate #>;
using HC.<#= project #>.Domain.Aggregate.<#= aggregate #>;
using HC.<#= project #>.Infrastructure.DomainPersistence.Repository.<#= aggregate #>;


namespace HC.<#= project #>.Application.Query
{
    public class <#= aggregate #>GetAllQH : QueryHandler<<#= aggregate #>GetAllQRY, IEnumerable<<#= aggregate #>VM>>
    {
        private readonly <#= aggregate #>Repository repository;

        public <#= aggregate #>GetAllQH(
            ILogger logger,
           <#= aggregate #>Repository repository
        )
            : base(logger)
        {
            Condition.Requires(repository, nameof(repository)).IsNotNull();

            repository = repository;
        }

        protected async override Task<IEnumerable<<#= aggregate #>VM>> ExecuteAsync(<#= aggregate #>GetAllQRY query)
        {
            // Conditions
            Condition.Requires(query, nameof(query)).IsNotNull();

            // Log line
            Log.Debug("Handle query", query.CorrelationUniqueId.ToUniqueId(), query);

            // Log line
            Log.Debug("Execute query", query.CorrelationUniqueId.ToUniqueId());

            // Start elapse time
            var sw = Stopwatch.StartNew();

            // Execute query
            var aggregates = await repository.FindAllAsync(Loading.Full, query.TenantUniqueId.ToTenantUniqueId());

            // Stop elapse time
            sw.Stop();

            // Log line
            Log.Debug("Executed query", query.CorrelationUniqueId.ToUniqueId(), sw.Elapsed);

            // Log line
            Log.Debug("Map result to VM", query.CorrelationUniqueId.ToUniqueId());

            // Map Aggregate to Viewmodel
            var result = ObjectContainer.Resolve<MappingProcessor>().Map<IEnumerable<<#= aggregate #>VM>>(aggregates);

            // Log line
            Log.Debug("Handling query is done", query.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "GetAllQH.cs");
  #>

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using FluentValidation;
using HC.Common;
using HC.<#= project #>.Application.Models.ViewModel.<#= aggregate #>;

namespace HC.<#= project #>.Application.Query
{
    public class <#= aggregate #>GetAllQV : QueryValidator<<#= aggregate #>GetAllQRY, IEnumerable<<#= aggregate #>VM>>
    {
        public <#= aggregate #>GetAllQV(
            ILogger logger
            )
            : base(logger)
        {
            // Validation rules
            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
        }

        protected async override Task<Result<IEnumerable<<#= aggregate #>VM>>> ExecuteAsync(<#= aggregate #>GetAllQRY query, string ruleSet = null)
        {
            // Conditions
            Condition.Requires(query, nameof(query)).IsNotNull();

            // Log line
            Log.Debug("Validate query", query.CorrelationUniqueId.ToUniqueId(), query);

            // init result
            var result = new Result<IEnumerable<<#= aggregate #>VM>>(await base.ValidateAsync(query));

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                Log.Debug("Fluent validation results are valid", query.CorrelationUniqueId.ToUniqueId());
            }
            else
            {
                // Log line
                Log.ValidationError("Fluent validation results are invalid", query.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            Log.Debug("Validation is done", query.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "GetAllQV.cs");
  #>
using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;

namespace HC.<#= project #>.Application.Query
{
    [Serializable]
    public class <#= aggregate #>GetAllQRY : HC.Query
    {
		[JsonConstructor]
        public <#= aggregate #>GetAllQRY(
            // Default props
            Guid tenantUniqueId,
            Guid correlationUniqueId,
            Guid userUniqueId
        )
            : base(tenantUniqueId, correlationUniqueId, userUniqueId)
        {
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "GetAllQRY.cs");
  #>

using HC.<#= project #>.Application.Query;
using HC.Common;
using HC.Integration.Domain.ValueObjects;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using HC.<#= project #>.Application.Models.ViewModel.<#= aggregate #>;
using HC.<#= project #>.Application.Models.InputModel.<#= aggregate #>;
using HC.<#= project #>.Application.Command;

namespace HC.<#= project #>.Application
{
    public class <#= aggregate #>AS
    {

        public async Task<Result<IEnumerable<<#= aggregate #>VM>>> GetAllAsync(Guid tenantUniqueId, Guid correlationUniqueId, Guid userUniqueId)
        {
            // Init query processor with query + parameters
            var queryProcessor = new QueryProcessor<<#= aggregate #>GetAllQRY, IEnumerable<<#= aggregate #>VM>>(new <#= aggregate #>GetAllQRY(tenantUniqueId, correlationUniqueId, userUniqueId));

            // Validate the query
            var result = await queryProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                result.Object = await queryProcessor.ProcessAsync();
            }

            return result;
        }
        public async Task<Result> CreateAsync(Guid userUniqueId, CreateA<#= aggregate #>IM model)
        {
            // Init command processor with parameters
            var commandProcessor = new CommandProcessor<CreateA<#= aggregate #>CMD>(
                new CreateA<#= aggregate #>CMD(
                    // Default props
                    tenantUniqueId: model.TenantUniqueId,
                    correlationUniqueId: model.CorrelationUniqueId,
                    userUniqueId: userUniqueId
<# for (int i = 0; i < properties.Length; i++)  { #>
					, model.<#= properties[i] #>
<# } #>   
                    ));

            // Validate the query
            var result = await commandProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                await commandProcessor.ProcessAsync();
            }
            return result;
        }
public async Task<Result> UpdateAsync(Guid userUniqueId, UpdateA<#= aggregate #>IM model)
        {
            // Init command processor with parameters
            var commandProcessor = new CommandProcessor<UpdateA<#= aggregate #>CMD>(
                new UpdateA<#= aggregate #>CMD(
                    // Default props
                    tenantUniqueId: model.TenantUniqueId,
                    correlationUniqueId: model.CorrelationUniqueId,
                    userUniqueId: userUniqueId,
					version : model.Version,
<# for (int i = 0; i < properties.Length; i++)  { #>
					, model.<#= properties[i] #>
<# } #>   
                    ));

            // Validate the query
            var result = await commandProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                await commandProcessor.ProcessAsync();
            }
            return result;
        }
        public async Task<Result> DeleteAsync(Guid userUniqueId, DeleteA<#= aggregate #>IM model)
        {
            // Init command processor with parameters
            var commandProcessor = new CommandProcessor<DeleteA<#= aggregate #>CMD>(
                new DeleteA<#= aggregate #>CMD(
                    // Default props
                    tenantUniqueId: model.TenantUniqueId,
                    correlationUniqueId: model.CorrelationUniqueId,
                    userUniqueId: userUniqueId,
                    version: model.Version,                    
                    uniqueId: model.UniqueId == null ? Guid.Empty : model.UniqueId
                ));

            // Validate the query
            var result = await commandProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                await commandProcessor.ProcessAsync();
            }
            return result;
        }  
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "AS.cs");
  #>

using System;
using System.Runtime.Serialization;
using AutoMapper;
using HC.<#= project #>.Domain.Aggregate.<#= aggregate #>;
using Newtonsoft.Json;

namespace HC.<#= project #>.Application.Models.ViewModel.<#= aggregate #>
{
   [Serializable]
    public class <#= aggregate #>VM : IViewModel, IObjectMapper
    {
        [DataMember]
        public Guid UniqueId { get; set; }        
      
<# for (int i = 0; i < properties.Length; i++)  { #>

		[DataMember]
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>       

        [DataMember]
        [JsonConverter(typeof(VersionConverter))]
        public long Version { get; set; }
		     
	    // TODO : check the mapping (most likely add .Value)
        public void CreateMap(IMapperConfigurationExpression config)
        {
            config.CreateMap<<#= aggregate #>AR, <#= aggregate #>VM>()
                .ForMember(f => f.Version, opt => opt.MapFrom(z => z.Version))
                .ForMember(f => f.UniqueId, opt => opt.MapFrom(z => z.UniqueId.Value))
<# for (int i = 0; i < properties.Length; i++)  { #>
			   .ForMember(f => f.<#= properties[i] #>, opt => opt.MapFrom(z => z.<#= properties[i] #>))
<# } #>
              ;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "VM.cs");
  #>
using System;
using System.Collections.Generic;
using System.Text;

namespace HC.<#= project #>.Application.Models.InputModel.CreateA<#= aggregate #>
{
    [Serializable]
    public class CreateA<#= aggregate #>IM : IInputModel
    {
        public Guid CorrelationUniqueId { get; set; }
        public Guid TenantUniqueId { get; set; }
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> { get; set; }
<# } #>    
    }
}
<#
  // End of file.
  SaveOutput("CreateA" + aggregate + "IM.cs");
  #>
using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;

namespace HC.<#= project #>.Application.Models.InputModel.UpdateA<#= aggregate #>
{
    [Serializable]
    public class UpdateA<#= aggregate #>IM : IInputModel
    {
        public Guid CorrelationUniqueId { get; set; }
        public Guid TenantUniqueId { get; set; }
		public Guid UniqueId { get; set; }		
        [JsonConverter(typeof(VersionConverter))]
        public long Version { get; set; }
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> { get; set; }
<# } #>    
    }
}
<#
  // End of file.
  SaveOutput("UpdateA" + aggregate + "IM.cs");
  #>


using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Text;

namespace HC.<#= project #>.Application.Models.InputModel.<#= aggregate #>
{
    [Serializable]
    public class DeleteA<#= aggregate #>IM : IInputModel
    {
        public Guid CorrelationUniqueId { get; set; }
        public Guid TenantUniqueId { get; set; }
       
        public Guid UniqueId { get; set; }
        [JsonConverter(typeof(VersionConverter))]
        public long Version { get; set; }
    }
}
<#
  // End of file.
  SaveOutput("DeleteA" + aggregate + "IM.cs");
  #>

using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using HC.Common;
using HC.Common.Infrastructure.DomainPersistence;
using HC.Common.Infrastructure.DomainPersistence.EF;
using HC.<#= project #>.Domain.Aggregate.<#= aggregate #>;
using HC.<#= project #>.Infrastructure.DomainPersistence.Entity;
namespace HC.<#= project #>.Infrastructure.DomainPersistence.Repository
{
    public class <#= aggregate #>Repository : AggregateEFRepository<<#= aggregate #>AR, <#= aggregate #>PE, ApplicationDbContext>
    {
        public <#= aggregate #>Repository(SqlServerContextFactory<<#= aggregate #>DbContext> factory, IContainerLifetimeScope scope)
            : base(factory, scope)
        {
        }

        public <#= aggregate #>Repository(IDbContextFactory<ApplicationDbContext> factory, IContainerLifetimeScope scope)
            : base(factory, scope)
        {
        }
        
        protected override IQueryable<<#= aggregate #>PE> PredicateForFullyLoadedAggregate(IQueryable<<#= aggregate #>PE> query)
        {
            return query;
        }

        protected override IQueryable<<#= aggregate #>PE> PredicateForSoberLoadedAggregate(IQueryable<<#= aggregate #>PE> query)
        {
            return query;
        }



        public async Task<bool> ExistsAsync(TenantUniqueId tenantUniqueId, UniqueId uniqueId)
        {
            Condition.Requires(tenantUniqueId, nameof(tenantUniqueId))
                .IsNotNull();
            Condition.Requires(uniqueId, nameof(uniqueId))
                .IsNotNull();

            return await base.AnyAsync(Loading.Sober, tenantUniqueId, f => f.UniqueId == uniqueId.Value);
        }       
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "Repository.cs");
  #>

using System;
using HC.Common.Infrastructure.DomainPersistence.EF;
using NServiceBus.Persistence;
namespace HC.<#= project #>.Infrastructure.DomainPersistence.Repository.<#= aggregate #>
{
    public class <#= aggregate #>NsbUnitOfWork : NsbUnitOfWorkBehavior<ApplicationDbContext>
    {
        public <#= aggregate #>NsbUnitOfWork(Func<SynchronizedStorageSession, ApplicationDbContext> contextFactory)
            : base(contextFactory)
        {

        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "NsbUnitOfWork.cs");
  #>
using HC.<#= project #>.Infrastructure.DomainPersistence.Repository;
using Microsoft.EntityFrameworkCore;
using NServiceBus;
using NServiceBus.Persistence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HC.<#= project #>.Infrastructure.Ioc
{
    public static class IocConfigInfrastructureExtensions
    {
        public static IocConfig RegisterInfrastructureComponents(this IocConfig iocConfig)
        {
            iocConfig.Builder.RegisterType(typeof(ApplicationDbContext));

            // Language- SQL Normal
            iocConfig.Builder.RegisterType(typeof(<#= aggregate #>Repository), null, LifeStyle.Singleton);

            return iocConfig;
        }
        public static IContainerLifetimeScope InitializeNServiceBusForEntityFramework(this IContainerLifetimeScope scope)
        {
            // GET CONFIGURATION + DELEGATE
            var endpointConfiguration = scope.Resolve<EndpointConfiguration>();
            var endpointConfigurationInstance = scope.ResolveDelegate<EndpointConfiguration>();

            // Get pipeline
            var pipeline = endpointConfiguration.Pipeline;

            // Register all the unit of works
            pipeline.Register(new <#= aggregate #>NsbUnitOfWork(PipelineRegistration(scope)), "<#= aggregate #>NsbUnitOfWork");

            // Delegate the configuration
            endpointConfigurationInstance(endpointConfiguration);

            return scope;
        }

        private static System.Func<SynchronizedStorageSession, ApplicationDbContext> PipelineRegistration(IContainerLifetimeScope scope)
        {
            return storageSession =>
            {
                // Get NSB dbConnection
                var dbConnection = storageSession.SqlPersistenceSession().Connection;

                // Get DbContext with NSB DbConnection
                var dbContext = scope.Resolve<ApplicationDbContext>(new Dictionary<string, object>()
                  {
                   { "connection", dbConnection }
                  });

                // Use the same underlying ADO.NET transaction
                dbContext.Database.UseTransaction(storageSession.SqlPersistenceSession().Transaction);

                // Call SaveChanges before completing storage session
                storageSession.SqlPersistenceSession().OnSaveChanges(async _ => await dbContext.SaveChangesAsync().ConfigureAwait(false));

                return dbContext;
            };
        }
    }
}
  <#
  // End of file.
  SaveOutput("IocConfigInfrastructureExtensions.cs");
  #>


using System.Data.Common;
using HC.Common.Infrastructure.DomainPersistence;
using HC.Common.Infrastructure.DomainPersistence.EF;
using HC.<#= project #>.Infrastructure.DomainPersistence.Entity;
using Microsoft.EntityFrameworkCore;

namespace HC.<#= project #>.Infrastructure.DomainPersistence.Repository
{
    public class <#= aggregate #>DbContext : PersistenceContext
    {
        public <#= aggregate #>DbContext(DbConnection connection) : base(connection)
        {
        }

        public <#= aggregate #>DbContext(DbConnection connection, DbContextOptions options) : base(connection, options)
        {
        }

        // ONLY USE THIS CONSTRUCTOR FOR TEST PURPOSE !!
        public <#= aggregate #>DbContext(DbContextOptions options)
            : base(null, options)
        {

        }
        public virtual DbSet<DomainEventStreamPE> DomainEventStream { get; set; }
        public virtual DbSet<ActivityLogPE> ActivityLogs { get; set; }
        public virtual DbSet<<#= aggregate #>PE> <#= aggregate #>s { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder
                .ApplyConfiguration(new TrackedEntityConfiguration<DomainEventStreamPE>())
                .ApplyConfiguration(new TrackedEntityConfiguration<ActivityLogPE>())
                .ApplyConfiguration(new AggregateConfiguration<<#= aggregate #>PE>())


                // MAPPER
                .ConfigurateAndMapDomainEventStream()               
                .Entity<<#= aggregate #>PE>(x =>
                {
				 x.ToTable("<#= aggregate #>", "dbo");
				<# for (int i = 0; i < properties.Length; i++){ #>
					x.Property(p => p.<#= properties[i] #>)
					.IsRequired()
					.HasColumnType("nvarchar(256)");
					//TODO :  refactor DB type above (nvarchar(256))
<# } #>                               
                })
                ;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "DbContext.cs");
  #>
  using HC.Common.Infrastructure.DomainPersistence;
using HC.Common.Infrastructure.DomainPersistence.EF;
using HC.Common.Infrastructure.DomainPersistence.Extensions;
using HC.Common.Infrastructure.Sharding;
using HC.<#= project #>.Infrastructure.DomainPersistence.Entity;
using Microsoft.EntityFrameworkCore;
using System.Data.Common;

namespace HC.<#= project #>.Infrastructure
{
    public class ApplicationDbContext : PersistenceContext
    {
        public ApplicationDbContext(DbConnection connection, ShardingInterceptor interceptor)
            : base(connection, interceptor) { }

        public ApplicationDbContext(DbConnection connection, DbContextOptions options, ShardingInterceptor interceptor)
            : base(connection, options, interceptor) { }

        // ONLY USE THIS CONSTRUCTOR FOR TEST PURPOSE !!
        public ApplicationDbContext(DbContextOptions options, ShardingInterceptor interceptor)
            : base(null, options, interceptor) { }

        public virtual DbSet<DomainEventStreamPE> DomainEventStream { get; set; }
        public virtual DbSet<ActivityLogPE> ActivityLogs { get; set; }
        public virtual DbSet<<#= aggregate #>PE> Tenant { get; set; }


        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder
                .ApplyConfiguration(new TrackedEntityConfiguration<ActivityLogPE>())
                .ApplyConfiguration(new TrackedEntityConfiguration<DomainEventStreamPE>())
                .ApplyConfiguration(new TrackedEntityConfiguration<<#= aggregate #>PE>())
                .ConfigurateAndMapDomainEventStream()

                // MAPPER
                .Entity<<#= aggregate #>PE>(x =>
                {
                    x.ToTable("<#= aggregate #>", "dbo");

                });              
        }
    }
}
  <#
  // End of file.
  SaveOutput("ApplicationDbContext.cs");
  #>

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using HC.Common;
using HC.Common.Infrastructure.DomainPersistence;
using HC.Integration.Domain.ValueObjects;
using HC.<#= project #>.Domain.Aggregate.<#= aggregate #>;

namespace HC.<#= project #>.Infrastructure.DomainPersistence.Entity
{
    public class <#= aggregate #>PE : TenantPersistenceEntity, IPersistenceEntityAggregateConvertible<<#= aggregate #>PE, <#= aggregate #>AR>
    {
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>       
        
        public Action<<#= aggregate #>PE> MapFromAggregate(<#= aggregate #>AR aggregate)
        {
            return p =>
            {                              
                p.TenantUniqueId = aggregate.TenantUniqueId.Value;
                p.UniqueId = aggregate.UniqueId.Value;
                p.Version = aggregate.Version;
<# for (int i = 0; i < properties.Length; i++)  { #>
				p.<#= properties[i] #> = aggregate.<#= properties[i] #>;
<# } #>                
            };
        }

        public Task<<#= aggregate #>AR> MapToAggregate(Loading type)
        {
            var <#= aggregate #> = new <#= aggregate #>AR(
                tenantUniqueId: TenantUniqueId.ToTenantUniqueId()
<# for (int i = 0; i < properties.Length; i++)  { #>
				,<#= properties[i] #>
<# } #>
                ,uniqueId: Common.UniqueId.Create(UniqueId)
                ,version: Version);

            // Mark as unchanged and return back to sender
            return Task.FromResult(<#= aggregate #>.Persistence_MarkAsUnchanged());
        }
    }

}
<#
  // End of file.
  SaveOutput(aggregate + "PE.cs");
  #>

using HC.Common;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Text;

namespace HC.<#= project #>.Domain.Aggregate.<#= aggregate #>.DE
{
    [Serializable]
    public class DeletedA<#= aggregate #>DE : DomainEvent
    {
        [JsonConstructor]
        public DeletedA<#= aggregate #>DE(TenantUniqueId tenantId, UniqueId id, long? version = null)
            : base(tenantId, id, version)
        {
            TenantUniqueId = tenantId;
            UniqueId = id;
        }
    }
}
<#
  // End of file.
  SaveOutput("DeletedA" + aggregate + "DE.cs");
  #>
// Domain event
using System;
using HC.Common;
using HC.Integration.Domain.ValueObjects;
using Newtonsoft.Json;

namespace HC.<#= project #>.Domain.Aggregate.<#= aggregate #>.DE
{
    [Serializable]
    public class CreatedA<#= aggregate #>DE : DomainEvent
    {
        [JsonConstructor]
        public CreatedA<#= aggregate #>DE(TenantUniqueId tenantUniqueId, UniqueId uniqueId
		 <# for (int i = 0; i < properties.Length; i++)  { #>
		,<#=  datatype[i] + " " + properties[i].ToLower() #>
		<# } #>
		)
            : base(tenantUniqueId, uniqueId)
        {
            Condition.Requires(nameof(tenantUniqueId)).IsNotNull();
            <# foreach (string propertyName in properties)  { #>
			<#= propertyName #> = <#= propertyName.ToLower() #>;
		   <# } #>
        }

       <# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
		<# } #>
    }
}
<#
  // End of file.
  SaveOutput("CreatedA" + aggregate + "DE.cs");
  #>


// Aggregate
using System;
using System.Collections.Generic;
using HC.Common;
using HC.Integration.Domain.ValueObjects;
using HC.<#= project #>.Domain.Aggregate.<#= aggregate #>.DE;

namespace HC.<#= project #>.Domain.Aggregate.<#= aggregate #>
{
    [Serializable]
    public class <#= classname #>AR : AggregateRoot<<#= aggregate #>AR>
    {
        #region Constructors
       public <#= classname #>AR(TenantUniqueId tenantUniqueId 
	   <# for (int i = 0; i < properties.Length; i++)  { #>
	   ,<#=  datatype[i] + " " + properties[i].ToLower() #>
		<# } #>
	   ,UniqueId uniqueId = null
	   ,long version = 1)
            : base(tenantUniqueId, uniqueId, version)
        {
            tenantUniqueId.Requires(nameof(tenantUniqueId))
                .IsNotNull();

            uniqueId.Requires(nameof(uniqueId))
                .IsNotNull();         

            Domain_ApplyEvent(new CreatedA<#= aggregate #>DE(
			TenantUniqueId
			,UniqueId
<# for (int i = 0; i < properties.Length; i++)  { #>
			,<#=  properties[i].ToLower() #>
<# } #>
			));
        }
        #endregion
        
        #region Properties
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>

        #endregion Properties

        #region Public methods

        public <#= classname #>AR Delete(long? version = null)
        {
            // Conditions
            Condition.Requires(CanDelete(), nameof(CanDelete)).IsTrue();

            // Init
            if (version.HasValue)
                Version = version.Value;
            Domain_ApplyEvent(new DeletedA<#= classname #>DE(TenantUniqueId, UniqueId));

            return this;
        }
		
		public <#= aggregate #>AR Update(<# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= datatype[i] + " " + ToCamelCase(properties[i]) #><# } #>)
        {
            // Conditions
            Condition.Requires(CanUpdate(<# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= ToCamelCase(properties[i]) #><# } #>), nameof(CanUpdate)).IsTrue();

            // Init
            Domain_ApplyEvent(new UpdatedA<#= aggregate #>DE(TenantUniqueId, UniqueId, <# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#=ToCamelCase(properties[i]) #><# } #>));

            return this;
        }


        #endregion


        #region Handlers

        private void Handle(CreatedA<#= classname #>DE evnt)
        {
<# foreach (string propertyName in properties)  { #>
		<#= propertyName #> = evnt.<#= propertyName #>;
<# } #>
        }      
        private void Handle(DeletedA<#= classname #>DE evnt)
        {
            Persistence_MarkAsDeleted();
        }

		private void <#= aggregate #>(UpdatedA<#= aggregate #>DE evnt)
        {
<# foreach (string propertyName in properties)  { #>
		<#= propertyName #> = evnt.<#= propertyName #>;
<# } #>
            
        }
        #endregion

        #region Validation methods

        public bool CanDelete()
        {
           // Add validation to delete !
		   // yield return Text; 
        }
		public bool CanUpdate(<# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= datatype[i] + " " + ToCamelCase(properties[i]) #><# } #>)
        {
            return true;
        }

    
        #endregion

        #region Public Overrides

        public override IEnumerable<ComparableValueObject> Domain_IdentityComponents()
        {
            //Needs to be filled in !
        }

        #endregion

        public static <#= classname #>AR Create(
		TenantUniqueId tenantUniqueId
		,UniqueId uniqueId
<# for (int i = 0; i < properties.Length; i++)  { #>
		,<#=  datatype[i] + " " + properties[i].ToLower() #>
<# } #>
		)
        {
            return new <#= classname #>AR(tenantUniqueId 
<# for (int i = 0; i < properties.Length; i++)  { #>
		,<#= properties[i].ToLower() #>
<# } #>
		,uniqueId);
        }
    }
}

<#
  // End of file.
  SaveOutput(classname + "AR.cs");
  #>
  using HC.Common;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Text;
using HC.Integration.Domain.ValueObjects;
using HC.<#= project #>.Domain.Aggregate.Shared;

namespace HC.<#= project #>.Domain.Aggregate.<#= aggregate #>.DE
{
    [Serializable]
    public class UpdatedA<#= aggregate #>DE : DomainEvent
    {
        [JsonConstructor]
        public UpdatedA<#= aggregate #>DE(TenantUniqueId tenantUniqueId, UniqueId uniqueId, <# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= datatype[i] + " " + ToCamelCase(properties[i]) #><# } #>)
            : base(tenantUniqueId, uniqueId)
        {
            uniqueId.Requires().IsNotNull();
<# foreach (string propertyName in properties)  { #>
		<#= propertyName #> = <#= propertyName.ToLower() #>;
<# } #>
        }
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>
    }
}
<#
  // End of file.
  SaveOutput("UpdatedA" + classname + "DE.cs");
  #>
<# if (appCommands){ #>
using Newtonsoft.Json;
using System;
namespace HC.<#= project #>.Application
{
[Serializable]
public class DeleteA<#= classname #>CMD : HC.Command
	{
	[JsonConstructor]
	public DeleteA<#= classname #>CMD(
	Guid tenantUniqueId, 
	Guid correlationUniqueId, 
	Guid userUniqueId,
	long version,
	Guid uniqueId
	) : base (tenantUniqueId, correlationUniqueId, userUniqueId , version)
	{
		UniqueId = uniqueId
	}
	public Guid UniqueId {get;set;}
	}
}

<#
  // End of file.
  SaveOutput("DeleteA" + classname + "CMD.cs");
  
  #>  
using System.Threading.Tasks;
using HC.Common;
using FluentValidation;
using FluentValidation.Results;
using System;

namespace HC.<#= project #>.Application.Command
{
    public class DeleteA<#= classname #>CV : CommandValidator<DeleteA<#= classname #>CMD>
    {
        private readonly <#= aggregate #>Repository repository;

        public DeleteA<#= classname #>CV(
            ILogger logger,
            <#= aggregate #>Repository repository
            )
            : base(logger)
        {
            // Conditions
            Condition.Requires(repository, nameof(repository)).IsNotNull();
            repository = repository;

			// Validation rules
			RuleFor(x => x.Version)
                .NotNull()
                .NotEqual(0)
                .WithSeverity(Severity.Error);

            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
        }
        public override async Task<Result> ExecuteAsync(DeleteA<#= classname #>CMD command, string ruleSet = null)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();

            // Log line
            Log.Debug("Validate command", command.CorrelationUniqueId.ToUniqueId(), command);

            // init result
            var result = new Result(await base.ValidateAsync(command), command.CorrelationUniqueId.ToUniqueId());

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                Log.Debug("Fluent validation results are valid", command.CorrelationUniqueId.ToUniqueId());

                 // Get aggregate from persistence
                var aggregate = await repository.FindAsync(Loading.Full, command.TenantUniqueId.ToTenantUniqueId(), command.UniqueId.ToUniqueId());

                if (aggregate == null)
                {
                    // Log line
                    Log.ValidationError("Can't find this <#= classname #> in the persistence.", command.CorrelationUniqueId.ToUniqueId(), command);

                    // Add property failure to result object
                    result.AddPropertyFailure("uniqueId", "Can't find this <#= classname #> in the persistence. Please re-check the conditions.");
                }
            }
            else
            {
                // Log line
                Log.ValidationError("Fluent validation results are invalid", command.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            Log.Debug("Validation is done", command.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput("DeleteA" + classname + "CV.cs");
  #>
using HC.Common;
using HC.<#= project#>.Application.Command;
using System;
using System.Threading.Tasks;
using HC.Common.Infrastructure.DomainPersistence;
namespace HC.<#= project#>.Application.Command
{
    public class DeleteA<#= classname#>CH : CommandHandler<DeleteA<#= classname#>CMD, <#= aggregate #>AR>
    {
        public DeleteA<#= classname#>CH(<#= aggregate #>Repository repository)
            : base(repository)
        {

        }

        protected override async Task ExecuteAsync(DeleteA<#= classname #>CMD command)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();
            command.UserUniqueId.Requires(nameof(command.UserUniqueId)).IsNotEqualTo(new Guid());
            command.TenantUniqueId.Requires(nameof(command.TenantUniqueId)).IsNotEqualTo(new Guid());
            command.CorrelationUniqueId.Requires(nameof(command.CorrelationUniqueId)).IsNotEqualTo(new Guid());

            // Log line
            Log.Debug("Handle command", command.CorrelationUniqueId.ToUniqueId(), command);

			// Get the aggregate from the persistence
            var aggregate = await Repository.FindAsync(Loading.Full, command.TenantUniqueId.ToTenantUniqueId(),
                command.UniqueId.ToUniqueId());

			// Delete the aggregate 
            aggregate = aggregate.Delete(command.Version);
			
			 // Save aggregate to DB
            await Repository.SaveAsync(command.CorrelationUniqueId.ToUniqueId(), command.UserUniqueId.ToUniqueId(), aggregate);

            
            // Log line
            Log.Debug("Handling command is done", command.CorrelationUniqueId.ToUniqueId());
        }
    }
}
<#
  // End of file.
  SaveOutput("DeleteA" + classname + "CH.cs");
  #>

// This is generated code:
using Newtonsoft.Json;
using System;
namespace HC.<#= project #>.Application
{
[Serializable]
public class CreateA<#= classname #>CMD : HC.Command
	{
	[JsonConstructor]
	public CreateA<#= classname #>CMD(
	Guid tenantUniqueId, 
	Guid correlationUniqueId, 
	Guid userUniqueId
<# if(version) #>
	,long version
<# for (int i = 0; i < properties.Length; i++)  { #>
	,<#=  datatype[i] + " " + properties[i].ToLower() #>
<# } #>
	) : base (tenantUniqueId, correlationUniqueId, userUniqueId<# if(version){#> , version<# }#>)
	{
<# foreach (string propertyName in properties)  { #>
		<#= propertyName #> = <#= propertyName.ToLower() #>;
<# } #>
	}

<# for (int i = 0; i < properties.Length; i++)  { #>
	public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>
	}
}

<#
  // End of file.
  SaveOutput("CreateA" + classname + "CMD.cs");
  
  #>  
using System.Threading.Tasks;
using HC.Common;
using FluentValidation;
using FluentValidation.Results;
using System;

namespace HC.<#= project #>.Application.Command
{
    public class CreateA<#= classname #>CV : CommandValidator<CreateA<#= classname #>CMD>
    {
        private readonly <#= aggregate #>Repository repository;

        public CreateA<#= classname #>CV(
            ILogger logger,
            <#= aggregate #>Repository repository
            )
            : base(logger)
        {
            // Conditions
            Condition.Requires(repository, nameof(repository)).IsNotNull();
            repository = repository;

			// Validation rules
<# if(version) {#>
			RuleFor(x => x.Version)
                .NotNull()
                .NotEqual(0)
                .WithSeverity(Severity.Error);
<#}#>
            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
<# for (int i = 0; i < properties.Length; i++)  { #>            
            RuleFor(x => x.<#= properties[i]#>)
                .NotNull();    
<#}#>
        }
        public override async Task<Result> ExecuteAsync(CreateA<#= classname #>CMD command, string ruleSet = null)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();

            // Log line
            Log.Debug("Validate command", command.CorrelationUniqueId.ToUniqueId(), command);

            // init result
            var result = new Result(await base.ValidateAsync(command), command.CorrelationUniqueId.ToUniqueId());

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                Log.Debug("Fluent validation results are valid", command.CorrelationUniqueId.ToUniqueId());
            }
            else
            {
                // Log line
                Log.ValidationError("Fluent validation results are invalid", command.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            Log.Debug("Validation is done", command.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput("CreateA" + classname + "CV.cs");
  #>
using HC.Common;
using HC.<#= project#>.Application.Command;
using System;
using System.Threading.Tasks;

namespace HC.<#= project#>.Application.Command
{
    public class CreateA<#= classname#>CH : CommandHandler<CreateA<#= classname#>CMD, <#= aggregate #>AR>
    {
        public CreateA<#= classname#>CH(<#= aggregate #>Repository repository)
            : base(repository)
        {

        }

        protected override async Task ExecuteAsync(CreateA<#= classname #>CMD command)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();
            command.UserUniqueId.Requires(nameof(command.UserUniqueId)).IsNotEqualTo(new Guid());
            command.TenantUniqueId.Requires(nameof(command.TenantUniqueId)).IsNotEqualTo(new Guid());
            command.CorrelationUniqueId.Requires(nameof(command.CorrelationUniqueId)).IsNotEqualTo(new Guid());

            // Log line
            Log.Debug("Handle command", command.CorrelationUniqueId.ToUniqueId(), command);

			// Create a new aggregate
            var aggregate = <#= aggregate #>AR.Create(command.TenantUniqueId.ToTenantUniqueId(), UniqueId.Generate()
<# for (int i = 0; i < properties.Length; i++)  { #>, command.<#= properties[i] #><#}#>);
			
			 // Save aggregate to DB
            await Repository.SaveAsync(command.CorrelationUniqueId.ToUniqueId(), command.UserUniqueId.ToUniqueId(), aggregate);

            
            // Log line
            Log.Debug("Handling command is done", command.CorrelationUniqueId.ToUniqueId());
        }
    }
}
<#
  // End of file.
  SaveOutput("CreateA" + classname + "CH.cs");
  #>





<#}
else{
#>

<# 
for (Int32 counter = 1; counter < numberOfSteps; ++counter) {
#>
// This is generated code:
using Newtonsoft.Json;
using System;
namespace HC.<#= project #>.Application
{
[Serializable]
public class <#= classname #><#= counter.ToString() #>CMD : HC.Command
	{
	[JsonConstructor]
	public <#= classname #><#= counter.ToString() #>CMD(
	Guid tenantUniqueId, 
	Guid correlationUniqueId, 
	Guid userUniqueId
<# if(version) #>
	,long version
<# for (int i = 0; i < properties.Length; i++)  { #>
	,<#=  datatype[i] + " " + properties[i].ToLower() #>
<# } #>
	) : base (tenantUniqueId, correlationUniqueId, userUniqueId<# if(version){#> , version<# }#>)
	{
<# foreach (string propertyName in properties)  { #>
		<#= propertyName #> = <#= propertyName.ToLower() #>;
<# } #>
	}

<# for (int i = 0; i < properties.Length; i++)  { #>
	public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>
	}
}

<#
  // End of file.
  SaveOutput(classname + counter.ToString() + "CMD.cs");
  
  #>

  
using System.Threading.Tasks;
using HC.Common;
using FluentValidation;
using FluentValidation.Results;
using System;

namespace HC.<#= project #>.Application.Command
{
    public class <#= classname #><#= counter.ToString() #>CV : CommandValidator<<#= classname #><#= counter.ToString() #>CMD>
    {
        private readonly <#= aggregate #>Repository repository;

        public <#= classname #><#= counter.ToString() #>CV(
            ILogger logger,
            <#= aggregate #>Repository repository
            )
            : base(logger)
        {
            // Conditions
            Condition.Requires(repository, nameof(repository)).IsNotNull();
            repository = repository;

			// Validation rules
<# if(version) {#>
			RuleFor(x => x.Version)
                .NotNull()
                .NotEqual(0)
                .WithSeverity(Severity.Error);
<#}#>
            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
<# for (int i = 0; i < properties.Length; i++)  { #>            
            RuleFor(x => x.<#= properties[i]#>)
                .NotNull();    
<#}#>
        }
        public override async Task<Result> ExecuteAsync(<#= classname #><#= counter.ToString() #>CMD command, string ruleSet = null)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();

            // Log line
            Log.Debug("Validate command", command.CorrelationUniqueId.ToUniqueId(), command);

            // init result
            var result = new Result(await base.ValidateAsync(command), command.CorrelationUniqueId.ToUniqueId());

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                Log.Debug("Fluent validation results are valid", command.CorrelationUniqueId.ToUniqueId());
            }
            else
            {
                // Log line
                Log.ValidationError("Fluent validation results are invalid", command.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            Log.Debug("Validation is done", command.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput(classname + counter.ToString() + "CV.cs");
  #>






using HC.Common;
using HC.<#= project#>.Application.Command;
using System;
using System.Threading.Tasks;

namespace HC.<#= project#>.Application.Command
{
    public class <#= classname#><#= counter.ToString() #>CH : CommandHandler<<#= classname#><#= counter.ToString() #>CMD, <#= aggregate #>AR>
    {
        public CreateA<#= classname#><#= counter.ToString() #>CH(<#= aggregate #>Repository repository)
            : base(repository)
        {

        }

        protected override async Task ExecuteAsync(<#= classname #><#= counter.ToString() #>CMD command)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();
            command.UserUniqueId.Requires(nameof(command.UserUniqueId)).IsNotEqualTo(new Guid());
            command.TenantUniqueId.Requires(nameof(command.TenantUniqueId)).IsNotEqualTo(new Guid());
            command.CorrelationUniqueId.Requires(nameof(command.CorrelationUniqueId)).IsNotEqualTo(new Guid());

            // Log line
            Log.Debug("Handle command", command.CorrelationUniqueId.ToUniqueId(), command);

			// Get the aggregate from the persistence
            var aggregate = await Repository.FindAsync(Loading.Full, command.TenantUniqueId.ToTenantUniqueId(),
                command.UniqueId.ToUniqueId());
			
			 // Save aggregate to DB
            await Repository.SaveAsync(command.CorrelationUniqueId.ToUniqueId(), command.UserUniqueId.ToUniqueId(), aggregate);

            
            // Log line
            Log.Debug("Handling command is done", command.CorrelationUniqueId.ToUniqueId());
        }
    }
}
<#
  // End of file.
  SaveOutput(classname + counter.ToString() + "CH.cs");
  #>

  <#
}
#>

<# } #>


<#+
private void SaveOutput(string outputFileName) {
  string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
  string outputFilePath = Path.Combine(templateDirectory, outputFileName);
  File.WriteAllText(outputFilePath, GenerationEnvironment.ToString()); 
  GenerationEnvironment.Remove(0, GenerationEnvironment.Length);
}
#>
<#+

     public string ToCamelCase(string str)
     {                    
         if(!string.IsNullOrEmpty(str) && str.Length > 1)
         {
             return Char.ToLowerInvariant(str[0]) + str.Substring(1);
         }
         return str;
     }
 
#>