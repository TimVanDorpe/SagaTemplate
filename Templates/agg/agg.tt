<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#@ template hostSpecific="true"#>
<# var datatype = new string [] {"Text" , "UniqueId" , "UniqueId"}; #>
<# var properties = new string [] {"Name", "FrameworkUniqueId", "CategoryUniqueId"}; #>
<# var project = "Isaac"; #>
<# var repository = "Alias"; #>
<# var aggregate = "Alias" ; #>
<# var classname = "Alias"; #>
<# var appCommands = true; #>
<# var numberOfSteps = 0; #>
<# var version = true; #>
using HC.Common;
using HC.Common.Presentation.Security;
using HC.Isaac.Api.Areas.API.Controllers;
using HC.Isaac.Application;
using HC.Isaac.Application.Models.InputModel.<#= aggregate #>;
using HC.Isaac.Application.Models.ViewModel.<#= aggregate #>;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;

namespace HC.Isaac.Api.Areas.API.Controllers
{
    [AuthorizeTenant(NeedsAdminAccess = true)]
    [Route("V4.0/{cultureInfo:length(2):alpha}/tenant/{tenantUniqueId:guid}/<#= aggregate #>")]
    public class <#= aggregate #>Controller : BaseController
    {
        private readonly <#= aggregate #>AS <#= aggregate.ToLower() #>AS;
        private readonly AppSettings appSettings;

        public <#= aggregate #>Controller()
        {
            this.<#= aggregate.ToLower() #>AS = ObjectContainer.Resolve<<#= aggregate #>AS>();
            this.appSettings = ObjectContainer.Resolve<AppSettings>();

            Condition.Requires(this.<#= aggregate.ToLower() #>AS, nameof(this.<#= aggregate.ToLower() #>AS)).IsNotNull();
            Condition.Requires(this.appSettings, nameof(this.appSettings)).IsNotNull();
        }

        [ProducesResponseType(statusCode: 200)]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpPost("Create")]
        public async Task<IActionResult> Create(
            [FromRoute]string cultureInfo,
            [FromBody]CreateA<#= aggregate #>IM model)
        {
            // Handle possible exceptions
            return await this.Exception.HandleForLoggingAsync(model.CorrelationUniqueId, model, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(this.Membership.GetToken().User.Id), UniqueId.CreateIfNotNull(model.CorrelationUniqueId), model);

                // Handle request
                var result = await this.<#= aggregate.ToLower() #>AS.CreateAsync(this.Membership.GetToken().User.Id, model);

                // Log response
                Log.Response(Request, sw, UniqueId.CreateIfNotNull(model.CorrelationUniqueId), result);

                // Return response
                if (result.IsValid)
                    return Ok();
                else
                    return BadRequest(result.Errors);
            });
        }

        [ProducesResponseType(statusCode: 200)]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpPut("Update")]
        public async Task<IActionResult> Update(
            [FromRoute]string cultureInfo,
            [FromBody]Update<#= aggregate #>IM model)
        {
            // Handle possible exceptions
            return await this.Exception.HandleForLoggingAsync(model.CorrelationUniqueId, model, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(this.Membership.GetToken().User.Id), UniqueId.CreateIfNotNull(model.CorrelationUniqueId), model);

                // Handle request
                var result = await this.<#= aggregate.ToLower() #>AS.UpdateAsync(this.Membership.GetToken().User.Id, model);

                // Log response
                Log.Response(Request, sw, UniqueId.CreateIfNotNull(model.CorrelationUniqueId), result);

                // Return response
                if (result.IsValid)
                    return Ok();
                else
                    return BadRequest(result.Errors);
            });
        }


        [ProducesResponseType(statusCode: 200)]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpPut("Delete")]
        public async Task<IActionResult> Delete(
            [FromRoute]string cultureInfo,
            [FromBody]DeleteA<#= aggregate #>IM model)
        {
            // Handle possible exceptions
            return await this.Exception.HandleForLoggingAsync(model.CorrelationUniqueId, model, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(this.Membership.GetToken().User.Id), UniqueId.CreateIfNotNull(model.CorrelationUniqueId), model);

                // Handle request
                var result = await this.<#= aggregate.ToLower() #>AS.DeleteAsync(this.Membership.GetToken().User.Id, model);

                // Log response
                Log.Response(Request, sw, UniqueId.CreateIfNotNull(model.CorrelationUniqueId), result);

                // Return response
                if (result.IsValid)
				    return Ok();
                else
                    return BadRequest(result.Errors);
 
            });
        }


        [ProducesResponseType(statusCode: 200, type: typeof(<#= aggregate #>VM[]))]
        [ProducesResponseType(statusCode: 400, type: typeof(ValidationError[]))]
        [HttpGet("GetAll")]
        public async Task<IActionResult> GetAll(
            [FromRoute] string cultureInfo,
            [FromRoute] Guid tenantUniqueId
            )
        {
            // Generate query id
            var queryUniqueId = UniqueId.Generate();

            // Handle possible exceptions
            return await this.Exception.HandleForLoggingAsync(queryUniqueId.Value, async () =>
            {
                // Log request
                var sw = Log.Request(Request, UniqueId.CreateIfNotNull(this.Membership.GetToken().User.Id), queryUniqueId);

                // Handle request
                var result = await this.<#= aggregate.ToLower() #>AS.GetAllAsync(appSettings.Security.SuperTenantUniqueId, queryUniqueId.Value, this.Membership.GetToken().User.Id);

                // Log response
                Log.Response(Request, sw, queryUniqueId, result);

                // Return response
                if (result.IsValid)
                    return Ok(result.Object);
                else
                    return BadRequest(result.Errors);
            });
        }
    }
}              
<#
  // End of file.
  SaveOutput(aggregate + "Controller.cs");
  #>
using System.Collections.Generic;
using HC.Common;
using System.Diagnostics;
using System.Threading.Tasks;
using HC.Common.Infrastructure.DomainPersistence;
using HC.Isaac.Application.Models.ViewModel.<#= aggregate #>;
using HC.Isaac.Domain.Aggregate.<#= aggregate #>;
using HC.Isaac.Infrastructure.DomainPersistence.Repository.<#= aggregate #>;


namespace HC.Isaac.Application.Query
{
    public class <#= aggregate #>GetAllQH : QueryHandler<<#= aggregate #>GetAllQRY, IEnumerable<<#= aggregate #>VM>>
    {
        private readonly <#= aggregate #>Repository repository;

        public <#= aggregate #>GetAllQH(
            ILogger logger,
           <#= aggregate #>Repository repository
        )
            : base(logger)
        {
            Condition.Requires(repository, nameof(repository)).IsNotNull();

            this.repository = repository;
        }

        protected async override Task<IEnumerable<<#= aggregate #>VM>> ExecuteAsync(<#= aggregate #>GetAllQRY query)
        {
            // Conditions
            Condition.Requires(query, nameof(query)).IsNotNull();

            // Log line
            this.Log.Debug("Handle query", query.CorrelationUniqueId.ToUniqueId(), query);

            // Log line
            this.Log.Debug("Execute query", query.CorrelationUniqueId.ToUniqueId());

            // Start elapse time
            var sw = Stopwatch.StartNew();

            // Execute query
            var aggregates = await this.repository.FindAllAsync(Loading.Full, query.TenantUniqueId.ToTenantUniqueId());

            // Stop elapse time
            sw.Stop();

            // Log line
            this.Log.Debug("Executed query", query.CorrelationUniqueId.ToUniqueId(), sw.Elapsed);

            // Log line
            this.Log.Debug("Map result to VM", query.CorrelationUniqueId.ToUniqueId());

            // Map Aggregate to Viewmodel
            var result = ObjectContainer.Resolve<MappingProcessor>().Map<IEnumerable<<#= aggregate #>VM>>(aggregates);

            // Log line
            this.Log.Debug("Handling query is done", query.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "GetAllQH.cs");
  #>

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using FluentValidation;
using HC.Common;
using HC.Isaac.Application.Models.ViewModel.<#= aggregate #>;

namespace HC.Isaac.Application.Query
{
    public class <#= aggregate #>GetAllQV : QueryValidator<<#= aggregate #>GetAllQRY, IEnumerable<<#= aggregate #>VM>>
    {
        public <#= aggregate #>GetAllQV(
            ILogger logger
            )
            : base(logger)
        {
            // Validation rules
            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
        }

        protected async override Task<Result<IEnumerable<<#= aggregate #>VM>>> ExecuteAsync(<#= aggregate #>GetAllQRY query, string ruleSet = null)
        {
            // Conditions
            Condition.Requires(query, nameof(query)).IsNotNull();

            // Log line
            this.Log.Debug("Validate query", query.CorrelationUniqueId.ToUniqueId(), query);

            // init result
            var result = new Result<IEnumerable<<#= aggregate #>VM>>(await base.ValidateAsync(query));

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                this.Log.Debug("Fluent validation results are valid", query.CorrelationUniqueId.ToUniqueId());
            }
            else
            {
                // Log line
                this.Log.ValidationError("Fluent validation results are invalid", query.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            this.Log.Debug("Validation is done", query.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "GetAllQV.cs");
  #>
using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;

namespace HC.Isaac.Application.Query
{
    [Serializable]
    public class <#= aggregate #>GetAllQRY : HC.Query
    {
		[JsonConstructor]
        public <#= aggregate #>GetAllQRY(
            // Default props
            Guid tenantUniqueId,
            Guid correlationUniqueId,
            Guid userUniqueId
        )
            : base(tenantUniqueId, correlationUniqueId, userUniqueId)
        {
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "GetAllQRY.cs");
  #>

using HC.Isaac.Application.Query;
using HC.Common;
using HC.Integration.Domain.ValueObjects;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using HC.Isaac.Application.Models.ViewModel.<#= aggregate #>;
using HC.Isaac.Application.Models.InputModel.<#= aggregate #>;
using HC.Isaac.Application.Command;

namespace HC.Isaac.Application
{
    public class <#= aggregate #>AS
    {

        public async Task<Result<IEnumerable<<#= aggregate #>VM>>> GetAllAsync(Guid tenantUniqueId, Guid correlationUniqueId, Guid userUniqueId)
        {
            // Init query processor with query + parameters
            var queryProcessor = new QueryProcessor<<#= aggregate #>GetAllQRY, IEnumerable<<#= aggregate #>VM>>(new <#= aggregate #>GetAllQRY(tenantUniqueId, correlationUniqueId, userUniqueId));

            // Validate the query
            var result = await queryProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                result.Object = await queryProcessor.ProcessAsync();
            }

            return result;
        }
        public async Task<Result> CreateAsync(Guid userUniqueId, CreateA<#= aggregate #>IM model)
        {
            // Init command processor with parameters
            var commandProcessor = new CommandProcessor<CreateA<#= aggregate #>CMD>(
                new CreateA<#= aggregate #>CMD(
                    // Default props
                    tenantUniqueId: model.TenantUniqueId,
                    correlationUniqueId: model.CorrelationUniqueId,
                    userUniqueId: userUniqueId
<# for (int i = 0; i < properties.Length; i++)  { #>
					, model.<#= properties[i] #>
<# } #>   
                    ));

            // Validate the query
            var result = await commandProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                await commandProcessor.ProcessAsync();
            }
            return result;
        }
public async Task<Result> UpdateAsync(Guid userUniqueId, UpdateA<#= aggregate #>IM model)
        {
            // Init command processor with parameters
            var commandProcessor = new CommandProcessor<UpdateA<#= aggregate #>CMD>(
                new UpdateA<#= aggregate #>CMD(
                    // Default props
                    tenantUniqueId: model.TenantUniqueId,
                    correlationUniqueId: model.CorrelationUniqueId,
                    userUniqueId: userUniqueId,
					version : model.Version,
<# for (int i = 0; i < properties.Length; i++)  { #>
					, model.<#= properties[i] #>
<# } #>   
                    ));

            // Validate the query
            var result = await commandProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                await commandProcessor.ProcessAsync();
            }
            return result;
        }
        public async Task<Result> DeleteAsync(Guid userUniqueId, DeleteA<#= aggregate #>IM model)
        {
            // Init command processor with parameters
            var commandProcessor = new CommandProcessor<DeleteA<#= aggregate #>CMD>(
                new DeleteA<#= aggregate #>CMD(
                    // Default props
                    tenantUniqueId: model.TenantUniqueId,
                    correlationUniqueId: model.CorrelationUniqueId,
                    userUniqueId: userUniqueId,
                    version: model.Version,                    
                    uniqueId: model.UniqueId == null ? Guid.Empty : model.UniqueId
                ));

            // Validate the query
            var result = await commandProcessor.ValidateAsync();

            // If the validation of the query was succesfull
            if (result.IsValid)
            {
                // Process the query from the persistence
                await commandProcessor.ProcessAsync();
            }
            return result;
        }  
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "AS.cs");
  #>

using System;
using System.Runtime.Serialization;
using AutoMapper;
using HC.Isaac.Domain.Aggregate.<#= aggregate #>;
using Newtonsoft.Json;

namespace HC.Isaac.Application.Models.ViewModel.<#= aggregate #>
{
   [Serializable]
    public class <#= aggregate #>VM : IViewModel, IObjectMapper
    {
        [DataMember]
        public Guid UniqueId { get; set; }        
      
<# for (int i = 0; i < properties.Length; i++)  { #>

		[DataMember]
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>       

        [DataMember]
        [JsonConverter(typeof(VersionConverter))]
        public long Version { get; set; }
		     
	    // TODO : check the mapping (most likely add .Value)
        public void CreateMap(IMapperConfigurationExpression config)
        {
            config.CreateMap<<#= aggregate #>AR, <#= aggregate #>VM>()
                .ForMember(f => f.Version, opt => opt.MapFrom(z => z.Version))
                .ForMember(f => f.UniqueId, opt => opt.MapFrom(z => z.UniqueId.Value))
<# for (int i = 0; i < properties.Length; i++)  { #>
			   .ForMember(f => f.<#= properties[i] #>, opt => opt.MapFrom(z => z.<#= properties[i] #>))
<# } #>
              ;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "VM.cs");
  #>
using System;
using System.Collections.Generic;
using System.Text;

namespace HC.Isaac.Application.Models.InputModel.CreateA<#= aggregate #>
{
    [Serializable]
    public class CreateA<#= aggregate #>IM : IInputModel
    {
        public Guid CorrelationUniqueId { get; set; }
        public Guid TenantUniqueId { get; set; }
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> { get; set; }
<# } #>    
    }
}
<#
  // End of file.
  SaveOutput("CreateA" + aggregate + "IM.cs");
  #>
using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;

namespace HC.Isaac.Application.Models.InputModel.UpdateA<#= aggregate #>
{
    [Serializable]
    public class UpdateA<#= aggregate #>IM : IInputModel
    {
        public Guid CorrelationUniqueId { get; set; }
        public Guid TenantUniqueId { get; set; }
		public Guid UniqueId { get; set; }		
        [JsonConverter(typeof(VersionConverter))]
        public long Version { get; set; }
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> { get; set; }
<# } #>    
    }
}
<#
  // End of file.
  SaveOutput("UpdateA" + aggregate + "IM.cs");
  #>


using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Text;

namespace HC.Isaac.Application.Models.InputModel.<#= aggregate #>
{
    [Serializable]
    public class DeleteA<#= aggregate #>IM : IInputModel
    {
        public Guid CorrelationUniqueId { get; set; }
        public Guid TenantUniqueId { get; set; }
       
        public Guid UniqueId { get; set; }
        [JsonConverter(typeof(VersionConverter))]
        public long Version { get; set; }
    }
}
<#
  // End of file.
  SaveOutput("DeleteA" + aggregate + "IM.cs");
  #>

using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using HC.Common;
using HC.Common.Infrastructure.DomainPersistence;
using HC.Common.Infrastructure.DomainPersistence.EF;
using HC.Isaac.Domain.Aggregate.<#= aggregate #>;
using HC.Isaac.Infrastructure.DomainPersistence.Entity;
namespace HC.Isaac.Infrastructure.DomainPersistence.Repository.<#= aggregate #>
{
    public class <#= aggregate #>Repository : AggregateEFRepository<<#= aggregate #>AR, <#= aggregate #>PE, <#= aggregate #>DbContext>
    {
        public <#= aggregate #>Repository(IAsyncDbContextFactory<<#= aggregate #>DbContext> factory)
            : base(factory, true)
        {
        }

        protected override IQueryable<<#= aggregate #>PE> PredicateForFullyLoadedAggregate(IQueryable<<#= aggregate #>PE> query)
        {
            return query;
        }       

        public async Task<bool> ExistsAsync(TenantUniqueId tenantUniqueId, UniqueId uniqueId)
        {
            Condition.Requires(tenantUniqueId, nameof(tenantUniqueId))
                .IsNotNull();
            Condition.Requires(uniqueId, nameof(uniqueId))
                .IsNotNull();

            return await base.AnyAsync(Loading.Sober, tenantUniqueId, f => f.UniqueId == uniqueId.Value);
        }       
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "Repository.cs");
  #>

using System;
using HC.Common.Infrastructure.DomainPersistence.EF;
using NServiceBus.Persistence;
namespace HC.Isaac.Infrastructure.DomainPersistence.Repository.<#= aggregate #>
{
    public class <#= aggregate #>NsbUnitOfWork : NsbUnitOfWorkBehavior<<#= aggregate #>DbContext>
    {
        public <#= aggregate #>NsbUnitOfWork(Func<SynchronizedStorageSession, <#= aggregate #>DbContext> contextFactory)
            : base(contextFactory)
        {

        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "NsbUnitOfWork.cs");
  #>

using System.Data.Common;
using HC.Common.Infrastructure.DomainPersistence;
using HC.Common.Infrastructure.DomainPersistence.EF;
using HC.Isaac.Infrastructure.DomainPersistence.Entity;
using Microsoft.EntityFrameworkCore;

namespace HC.Isaac.Infrastructure.DomainPersistence.Repository.<#= aggregate #>
{
    public class <#= aggregate #>DbContext : PersistenceContext
    {
        public <#= aggregate #>DbContext(DbConnection connection) : base(connection)
        {
        }

        public <#= aggregate #>DbContext(DbConnection connection, DbContextOptions options) : base(connection, options)
        {
        }

        // ONLY USE THIS CONSTRUCTOR FOR TEST PURPOSE !!
        public <#= aggregate #>DbContext(DbContextOptions options)
            : base(null, options)
        {

        }
        public virtual DbSet<DomainEventStreamPE> DomainEventStream { get; set; }
        public virtual DbSet<ActivityLogPE> ActivityLogs { get; set; }
        public virtual DbSet<<#= aggregate #>PE> <#= aggregate #>s { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder
                .ApplyConfiguration(new TrackedEntityConfiguration<DomainEventStreamPE>())
                .ApplyConfiguration(new TrackedEntityConfiguration<ActivityLogPE>())
                .ApplyConfiguration(new AggregateConfiguration<<#= aggregate #>PE>())


                // MAPPER
                .ConfigurateAndMapDomainEventStream()               
                .Entity<<#= aggregate #>PE>(x =>
                {
				 x.ToTable("<#= aggregate #>", "dbo");
				<# for (int i = 0; i < properties.Length; i++){ #>
					x.Property(p => p.<#= properties[i] #>)
					.IsRequired()
					.HasColumnType("nvarchar(256)");
					//TODO :  refactor DB type above (nvarchar(256))
<# } #>                               
                })
                ;
        }
    }
}
<#
  // End of file.
  SaveOutput(aggregate + "DbContext.cs");
  #>

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using HC.Common;
using HC.Common.Infrastructure.DomainPersistence;
using HC.Integration.Domain.ValueObjects;
using HC.Isaac.Domain.Aggregate.<#= aggregate #>;

namespace HC.Isaac.Infrastructure.DomainPersistence.Entity
{
    public class <#= aggregate #>PE : TenantPersistenceEntity, IPersistenceEntityAggregateConvertible<<#= aggregate #>PE, <#= aggregate #>AR>
    {
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>       
        
        public Action<<#= aggregate #>PE> MapFromAggregate(<#= aggregate #>AR aggregate)
        {
            return p =>
            {                
                p.State = aggregate.State;
                p.TenantUniqueId = aggregate.TenantUniqueId.Value;
                p.UniqueId = aggregate.UniqueId.Value;
                p.Version = aggregate.Version;
<# for (int i = 0; i < properties.Length; i++)  { #>
				p.<#= properties[i] #> = aggregate.<#= properties[i] #>;
<# } #>                
            };
        }

        public Task<<#= aggregate #>AR> MapToAggregate(Loading type)
        {
            var <#= aggregate #> = new <#= aggregate #>AR(
                tenantUniqueId: this.TenantUniqueId.ToTenantUniqueId()
<# for (int i = 0; i < properties.Length; i++)  { #>
				,this.<#= properties[i] #>
<# } #>
                ,uniqueId: Common.UniqueId.Create(this.UniqueId)
                ,state: type == Loading.Full
                    ? PersistenceState.FullyLoadedFromPersistence
                    : PersistenceState.SoberLoadedFromPersistence, version: this.Version);

            // Mark as unchanged and return back to sender
            return Task.FromResult(<#= aggregate #>.Persistence_MarkAsUnchanged());
        }
    }

}
<#
  // End of file.
  SaveOutput(aggregate + "PE.cs");
  #>

using HC.Common;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Text;

namespace HC.Isaac.Domain.Aggregate.<#= aggregate #>.DE
{
    [Serializable]
    public class DeletedA<#= aggregate #>DE : DomainEvent
    {
        [JsonConstructor]
        public DeletedA<#= aggregate #>DE(TenantUniqueId tenantId, UniqueId id, long? version = null)
            : base(tenantId, id, version)
        {
            this.TenantUniqueId = tenantId;
            this.UniqueId = id;
        }
    }
}
<#
  // End of file.
  SaveOutput("DeletedA" + aggregate + "DE.cs");
  #>
// Domain event
using System;
using HC.Common;
using HC.Integration.Domain.ValueObjects;
using Newtonsoft.Json;

namespace HC.Isaac.Domain.Aggregate.<#= aggregate #>.DE
{
    [Serializable]
    public class CreatedA<#= aggregate #>DE : DomainEvent
    {
        [JsonConstructor]
        public CreatedA<#= aggregate #>DE(TenantUniqueId tenantUniqueId, UniqueId uniqueId
		 <# for (int i = 0; i < properties.Length; i++)  { #>
		,<#=  datatype[i] + " " + properties[i].ToLower() #>
		<# } #>
		)
            : base(tenantUniqueId, uniqueId)
        {
            Condition.Requires(nameof(tenantUniqueId)).IsNotNull();
            <# foreach (string propertyName in properties)  { #>
			this.<#= propertyName #> = <#= propertyName.ToLower() #>;
		   <# } #>
        }

       <# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
		<# } #>
    }
}
<#
  // End of file.
  SaveOutput("CreatedA" + aggregate + "DE.cs");
  #>


// Aggregate
using System;
using System.Collections.Generic;
using HC.Common;
using HC.Integration.Domain.ValueObjects;
using HC.Isaac.Domain.Aggregate.<#= aggregate #>.DE;

namespace HC.Isaac.Domain.Aggregate.<#= aggregate #>
{
    [Serializable]
    public class <#= classname #>AR : AggregateRoot<<#= aggregate #>AR>
    {
        #region Constructors
       public <#= classname #>AR(TenantUniqueId tenantUniqueId 
	   <# for (int i = 0; i < properties.Length; i++)  { #>
	   , <#=  datatype[i] + " " + properties[i].ToLower() #>
		<# } #>
	   , UniqueId uniqueId = null
       , PersistenceState state = PersistenceState.Unchanged
	   , long version = 1)
            : base(tenantUniqueId, uniqueId, state, version)
        {
            tenantUniqueId.Requires(nameof(tenantUniqueId))
                .IsNotNull();

            uniqueId.Requires(nameof(uniqueId))
                .IsNotNull();
         
		 // Check if anything needs to be required

          state.Requires()
                .Evaluate(x => x != PersistenceState.SoberLoadedFromPersistence, "This aggregate doesn't support the sober loading from persistence");

            Domain_ApplyEvent(new CreatedA<#= aggregate #>DE(
			this.TenantUniqueId
			,this.UniqueId
<# for (int i = 0; i < properties.Length; i++)  { #>
			,<#=  properties[i].ToLower() #>
<# } #>
			));
        }
        #endregion
        
        #region Properties
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>

        #endregion Properties

        #region Public methods

        public <#= classname #>AR Delete(long? version = null)
        {
            // Conditions
            Condition.Requires(this.CanDelete(), nameof(CanDelete)).IsTrue();

            // Init
            if (version.HasValue)
                this.Version = version.Value;
            Domain_ApplyEvent(new DeletedA<#= classname #>DE(this.TenantUniqueId, this.UniqueId));

            return this;
        }
		
		  public <#= aggregate #>AR Update(<# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= datatype[i] + " " + ToCamelCase(properties[i]) #><# } #>           
            )
        {
            // Conditions
            Condition.Requires(this.CanUpdate(<# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= ToCamelCase(properties[i]) #><# } #>), nameof(CanUpdate)).IsTrue();

            // Init
            Domain_ApplyEvent(new UpdatedA<#= aggregate #>DE(this.TenantUniqueId, this.UniqueId <# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#=ToCamelCase(properties[i]) #><# } #>));

            return this;
        }


        #endregion


        #region Handlers

        private void Handle(CreatedA<#= classname #>DE evt)
        {
<# foreach (string propertyName in properties)  { #>
		this.<#= propertyName #> = evt.<#= propertyName #>;
<# } #>
        }      
        private void Handle(DeletedA<#= classname #>DE evnt)
        {
            this.Persistence_MarkAsDeleted();
        }

		private void <#= aggregate #>(UpdatedAPosWordStringDE evnt)
        {
<# foreach (string propertyName in properties)  { #>
		this.<#= propertyName #> = evt.<#= propertyName #>;
<# } #>
            
        }
        #endregion

        #region Validation methods

        public bool CanDelete()
        {
           // Add validation to delete !
		   // yield return this.Text; 
        }
		public bool CanUpdate(<# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= datatype[i] + " " + ToCamelCase(properties[i]) #><# } #>)
        {
            return true;
        }

    
        #endregion

        #region Public Overrides

        public override IEnumerable<ComparableValueObject> Domain_IdentityComponents()
        {
            //Needs to be filled in !
        }

        #endregion

        public static <#= classname #>AR Create(
		TenantUniqueId tenantUniqueId
		,UniqueId uniqueId
<# for (int i = 0; i < properties.Length; i++)  { #>
		,<#=  datatype[i] + " " + properties[i].ToLower() #>
<# } #>
		)
        {
            return new <#= classname #>AR(tenantUniqueId 
<# for (int i = 0; i < properties.Length; i++)  { #>
		,<#= properties[i].ToLower() #>
<# } #>
		,uniqueId
		,PersistenceState.Added);
        }


    }
}

<#
  // End of file.
  SaveOutput(classname + "AR.cs");
  #>
  using HC.Common;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Text;
using HC.Integration.Domain.ValueObjects;
using HC.Isaac.Domain.Aggregate.Shared;

namespace HC.Isaac.Domain.Aggregate.<#= aggregate #>.DE
{
    [Serializable]
    public class UpdatedA<#= aggregate #>DE : DomainEvent
    {
        [JsonConstructor]
        public UpdatedA<#= aggregate #>DE(TenantUniqueId tenantUniqueId, UniqueId uniqueId, <# for (int i = 0; i < properties.Length; i++)  { #><# if(i > 0) { #> ,<# } #> <#= datatype[i] + " " + ToCamelCase(properties[i]) #><# } #>)
            : base(tenantUniqueId, uniqueId)
        {
            uniqueId.Requires().IsNotNull();
<# foreach (string propertyName in properties)  { #>
		this.<#= propertyName #> = <#= propertyName.ToLower() #>;
<# } #>
        }
<# for (int i = 0; i < properties.Length; i++)  { #>
		public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>
    }
}
<#
  // End of file.
  SaveOutput("UpdatedA" + classname + "DE.cs");
  #>
<# if (appCommands){ #>
using Newtonsoft.Json;
using System;
namespace HC.<#= project #>.Application
{
[Serializable]
public class DeleteA<#= classname #>CMD : HC.Command
	{
	[JsonConstructor]
	public DeleteA<#= classname #>CMD(
	Guid tenantUniqueId, 
	Guid correlationUniqueId, 
	Guid userUniqueId,
	long version,
	Guid uniqueId
	) : base (tenantUniqueId, correlationUniqueId, userUniqueId , version)
	{
		this.UniqueId = uniqueId
	}
	public Guid UniqueId {get;set;}
	}
}

<#
  // End of file.
  SaveOutput("DeleteA" + classname + "CMD.cs");
  
  #>  
using System.Threading.Tasks;
using HC.Common;
using FluentValidation;
using FluentValidation.Results;
using System;

namespace HC.<#= project #>.Application.Command
{
    public class DeleteA<#= classname #>CV : CommandValidator<DeleteA<#= classname #>CMD>
    {
        private readonly <#= aggregate #>Repository repository;

        public DeleteA<#= classname #>CV(
            ILogger logger,
            <#= aggregate #>Repository repository
            )
            : base(logger)
        {
            // Conditions
            Condition.Requires(repository, nameof(repository)).IsNotNull();
            this.repository = repository;

			// Validation rules
			RuleFor(x => x.Version)
                .NotNull()
                .NotEqual(0)
                .WithSeverity(Severity.Error);

            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
        }
        public override async Task<Result> ExecuteAsync(DeleteA<#= classname #>CMD command, string ruleSet = null)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();

            // Log line
            this.Log.Debug("Validate command", command.CorrelationUniqueId.ToUniqueId(), command);

            // init result
            var result = new Result(await base.ValidateAsync(command), command.CorrelationUniqueId.ToUniqueId());

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                this.Log.Debug("Fluent validation results are valid", command.CorrelationUniqueId.ToUniqueId());

                 // Get aggregate from persistence
                var aggregate = await this.repository.FindAsync(Loading.Full, command.TenantUniqueId.ToTenantUniqueId(), command.UniqueId.ToUniqueId());

                if (aggregate == null)
                {
                    // Log line
                    this.Log.ValidationError("Can't find this <#= classname #> in the persistence.", command.CorrelationUniqueId.ToUniqueId(), command);

                    // Add property failure to result object
                    result.AddPropertyFailure("uniqueId", "Can't find this <#= classname #> in the persistence. Please re-check the conditions.");
                }
            }
            else
            {
                // Log line
                this.Log.ValidationError("Fluent validation results are invalid", command.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            this.Log.Debug("Validation is done", command.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput("DeleteA" + classname + "CV.cs");
  #>
using HC.Common;
using HC.<#= project#>.Application.Command;
using System;
using System.Threading.Tasks;
using HC.Common.Infrastructure.DomainPersistence;
namespace HC.<#= project#>.Application.Command
{
    public class DeleteA<#= classname#>CH : CommandHandler<DeleteA<#= classname#>CMD, <#= aggregate #>AR>
    {
        public DeleteA<#= classname#>CH(<#= aggregate #>Repository repository)
            : base(repository)
        {

        }

        protected override async Task ExecuteAsync(DeleteA<#= classname #>CMD command)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();
            command.UserUniqueId.Requires(nameof(command.UserUniqueId)).IsNotEqualTo(new Guid());
            command.TenantUniqueId.Requires(nameof(command.TenantUniqueId)).IsNotEqualTo(new Guid());
            command.CorrelationUniqueId.Requires(nameof(command.CorrelationUniqueId)).IsNotEqualTo(new Guid());

            // Log line
            this.Log.Debug("Handle command", command.CorrelationUniqueId.ToUniqueId(), command);

			// Get the aggregate from the persistence
            var aggregate = await this.Repository.FindAsync(Loading.Full, command.TenantUniqueId.ToTenantUniqueId(),
                command.UniqueId.ToUniqueId());

			// Delete the aggregate 
            aggregate = aggregate.Delete(command.Version);
			
			 // Save aggregate to DB
            await this.Repository.SaveAsync(command.CorrelationUniqueId.ToUniqueId(), command.UserUniqueId.ToUniqueId(), aggregate);

            
            // Log line
            this.Log.Debug("Handling command is done", command.CorrelationUniqueId.ToUniqueId());
        }
    }
}
<#
  // End of file.
  SaveOutput("DeleteA" + classname + "CH.cs");
  #>

// This is generated code:
using Newtonsoft.Json;
using System;
namespace HC.<#= project #>.Application
{
[Serializable]
public class CreateA<#= classname #>CMD : HC.Command
	{
	[JsonConstructor]
	public CreateA<#= classname #>CMD(
	Guid tenantUniqueId, 
	Guid correlationUniqueId, 
	Guid userUniqueId
<# if(version) #>
	,long version
<# for (int i = 0; i < properties.Length; i++)  { #>
	,<#=  datatype[i] + " " + properties[i].ToLower() #>
<# } #>
	) : base (tenantUniqueId, correlationUniqueId, userUniqueId<# if(version){#> , version<# }#>)
	{
<# foreach (string propertyName in properties)  { #>
		this.<#= propertyName #> = <#= propertyName.ToLower() #>;
<# } #>
	}

<# for (int i = 0; i < properties.Length; i++)  { #>
	public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>
	}
}

<#
  // End of file.
  SaveOutput("CreateA" + classname + "CMD.cs");
  
  #>  
using System.Threading.Tasks;
using HC.Common;
using FluentValidation;
using FluentValidation.Results;
using System;

namespace HC.<#= project #>.Application.Command
{
    public class CreateA<#= classname #>CV : CommandValidator<CreateA<#= classname #>CMD>
    {
        private readonly <#= aggregate #>Repository repository;

        public CreateA<#= classname #>CV(
            ILogger logger,
            <#= aggregate #>Repository repository
            )
            : base(logger)
        {
            // Conditions
            Condition.Requires(repository, nameof(repository)).IsNotNull();
            this.repository = repository;

			// Validation rules
<# if(version) {#>
			RuleFor(x => x.Version)
                .NotNull()
                .NotEqual(0)
                .WithSeverity(Severity.Error);
<#}#>
            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
<# for (int i = 0; i < properties.Length; i++)  { #>            
            RuleFor(x => x.<#= properties[i]#>)
                .NotNull();    
<#}#>
        }
        public override async Task<Result> ExecuteAsync(CreateA<#= classname #>CMD command, string ruleSet = null)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();

            // Log line
            this.Log.Debug("Validate command", command.CorrelationUniqueId.ToUniqueId(), command);

            // init result
            var result = new Result(await base.ValidateAsync(command), command.CorrelationUniqueId.ToUniqueId());

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                this.Log.Debug("Fluent validation results are valid", command.CorrelationUniqueId.ToUniqueId());
            }
            else
            {
                // Log line
                this.Log.ValidationError("Fluent validation results are invalid", command.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            this.Log.Debug("Validation is done", command.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput("CreateA" + classname + "CV.cs");
  #>
using HC.Common;
using HC.<#= project#>.Application.Command;
using System;
using System.Threading.Tasks;

namespace HC.<#= project#>.Application.Command
{
    public class CreateA<#= classname#>CH : CommandHandler<CreateA<#= classname#>CMD, <#= aggregate #>AR>
    {
        public CreateA<#= classname#>CH(<#= aggregate #>Repository repository)
            : base(repository)
        {

        }

        protected override async Task ExecuteAsync(CreateA<#= classname #>CMD command)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();
            command.UserUniqueId.Requires(nameof(command.UserUniqueId)).IsNotEqualTo(new Guid());
            command.TenantUniqueId.Requires(nameof(command.TenantUniqueId)).IsNotEqualTo(new Guid());
            command.CorrelationUniqueId.Requires(nameof(command.CorrelationUniqueId)).IsNotEqualTo(new Guid());

            // Log line
            this.Log.Debug("Handle command", command.CorrelationUniqueId.ToUniqueId(), command);

			// Create a new aggregate
            var aggregate = <#= aggregate #>AR.Create(command.TenantUniqueId.ToTenantUniqueId(), UniqueId.Generate()
<# for (int i = 0; i < properties.Length; i++)  { #>, command.<#= properties[i] #><#}#>);
			
			 // Save aggregate to DB
            await this.Repository.SaveAsync(command.CorrelationUniqueId.ToUniqueId(), command.UserUniqueId.ToUniqueId(), aggregate);

            
            // Log line
            this.Log.Debug("Handling command is done", command.CorrelationUniqueId.ToUniqueId());
        }
    }
}
<#
  // End of file.
  SaveOutput("CreateA" + classname + "CH.cs");
  #>





<#}
else{
#>

<# 
for (Int32 counter = 1; counter < numberOfSteps; ++counter) {
#>
// This is generated code:
using Newtonsoft.Json;
using System;
namespace HC.<#= project #>.Application
{
[Serializable]
public class <#= classname #><#= counter.ToString() #>CMD : HC.Command
	{
	[JsonConstructor]
	public <#= classname #><#= counter.ToString() #>CMD(
	Guid tenantUniqueId, 
	Guid correlationUniqueId, 
	Guid userUniqueId
<# if(version) #>
	,long version
<# for (int i = 0; i < properties.Length; i++)  { #>
	,<#=  datatype[i] + " " + properties[i].ToLower() #>
<# } #>
	) : base (tenantUniqueId, correlationUniqueId, userUniqueId<# if(version){#> , version<# }#>)
	{
<# foreach (string propertyName in properties)  { #>
		this.<#= propertyName #> = <#= propertyName.ToLower() #>;
<# } #>
	}

<# for (int i = 0; i < properties.Length; i++)  { #>
	public <#= datatype[i] + " " + properties[i] #> {get;set;}
<# } #>
	}
}

<#
  // End of file.
  SaveOutput(classname + counter.ToString() + "CMD.cs");
  
  #>

  
using System.Threading.Tasks;
using HC.Common;
using FluentValidation;
using FluentValidation.Results;
using System;

namespace HC.<#= project #>.Application.Command
{
    public class <#= classname #><#= counter.ToString() #>CV : CommandValidator<<#= classname #><#= counter.ToString() #>CMD>
    {
        private readonly <#= aggregate #>Repository repository;

        public <#= classname #><#= counter.ToString() #>CV(
            ILogger logger,
            <#= aggregate #>Repository repository
            )
            : base(logger)
        {
            // Conditions
            Condition.Requires(repository, nameof(repository)).IsNotNull();
            this.repository = repository;

			// Validation rules
<# if(version) {#>
			RuleFor(x => x.Version)
                .NotNull()
                .NotEqual(0)
                .WithSeverity(Severity.Error);
<#}#>
            RuleFor(x => x.TenantUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.UserUniqueId)
                .NotNull()
                .NotEqual(new Guid());

            RuleFor(x => x.CorrelationUniqueId)
               .NotNull()
                .NotEqual(new Guid());
<# for (int i = 0; i < properties.Length; i++)  { #>            
            RuleFor(x => x.<#= properties[i]#>)
                .NotNull();    
<#}#>
        }
        public override async Task<Result> ExecuteAsync(<#= classname #><#= counter.ToString() #>CMD command, string ruleSet = null)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();

            // Log line
            this.Log.Debug("Validate command", command.CorrelationUniqueId.ToUniqueId(), command);

            // init result
            var result = new Result(await base.ValidateAsync(command), command.CorrelationUniqueId.ToUniqueId());

            // If fluent validation properties are valid
            if (result.IsValid)
            {
                // Log line
                this.Log.Debug("Fluent validation results are valid", command.CorrelationUniqueId.ToUniqueId());
            }
            else
            {
                // Log line
                this.Log.ValidationError("Fluent validation results are invalid", command.CorrelationUniqueId.ToUniqueId(), result);
            }

            // Log line
            this.Log.Debug("Validation is done", command.CorrelationUniqueId.ToUniqueId());

            // Return result
            return result;
        }
    }
}
<#
  // End of file.
  SaveOutput(classname + counter.ToString() + "CV.cs");
  #>






using HC.Common;
using HC.<#= project#>.Application.Command;
using System;
using System.Threading.Tasks;

namespace HC.<#= project#>.Application.Command
{
    public class <#= classname#><#= counter.ToString() #>CH : CommandHandler<<#= classname#><#= counter.ToString() #>CMD, <#= aggregate #>AR>
    {
        public CreateA<#= classname#><#= counter.ToString() #>CH(<#= aggregate #>Repository repository)
            : base(repository)
        {

        }

        protected override async Task ExecuteAsync(<#= classname #><#= counter.ToString() #>CMD command)
        {
            // Conditions
            command.Requires(nameof(command)).IsNotNull();
            command.UserUniqueId.Requires(nameof(command.UserUniqueId)).IsNotEqualTo(new Guid());
            command.TenantUniqueId.Requires(nameof(command.TenantUniqueId)).IsNotEqualTo(new Guid());
            command.CorrelationUniqueId.Requires(nameof(command.CorrelationUniqueId)).IsNotEqualTo(new Guid());

            // Log line
            this.Log.Debug("Handle command", command.CorrelationUniqueId.ToUniqueId(), command);

			// Get the aggregate from the persistence
            var aggregate = await this.Repository.FindAsync(Loading.Full, command.TenantUniqueId.ToTenantUniqueId(),
                command.UniqueId.ToUniqueId());
			
			 // Save aggregate to DB
            await this.Repository.SaveAsync(command.CorrelationUniqueId.ToUniqueId(), command.UserUniqueId.ToUniqueId(), aggregate);

            
            // Log line
            this.Log.Debug("Handling command is done", command.CorrelationUniqueId.ToUniqueId());
        }
    }
}
<#
  // End of file.
  SaveOutput(classname + counter.ToString() + "CH.cs");
  #>

  <#
}
#>

<# } #>


<#+
private void SaveOutput(string outputFileName) {
  string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
  string outputFilePath = Path.Combine(templateDirectory, outputFileName);
  File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString()); 
  this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}
#>
<#+

     public string ToCamelCase(string str)
     {                    
         if(!string.IsNullOrEmpty(str) && str.Length > 1)
         {
             return Char.ToLowerInvariant(str[0]) + str.Substring(1);
         }
         return str;
     }
 
#>